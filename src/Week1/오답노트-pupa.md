# 백준 15721 번데기 오답노트

## 문제 설명

[백준 15721](https://www.acmicpc.net/problem/15721)

Input

첫째 줄에 게임을 진행하는 사람 A명이 주어진다. A는 2,000보다 작거나 같은 자연수이다.

둘째 줄에는 구하고자 하는 번째 T가 주어진다. (T ≤ 10000)

셋째 줄에는 구하고자 하는 구호가 “뻔”이면 0, “데기”면 1로 주어진다.

---

Output

첫째 줄에 구하고자 하는 사람이 원탁에서 몇 번째에 있는지 정수로 출력한다.

## 접근 방식

처음 0 1 의 순서를 구현할 때

```
0 1 0 1 0 0 1 1
0 1 0 1 0 0 0 1 1 1
0 1 0 1 0 0 0 0 1 1 1 1
...
```

식으로 순환 배열이 늘어납니다.

등차를 구해 초기 배열을 구하고, 배열을 돌면서 0 1 중 타겟에 해당하는 값이 있으면 카운트를 더하는 식으로 진행해 T 에 도달하면 전체 count 를 A 로 나눠서 구하고자 했습니다.

## 틀린 이유 설명

지금 쓰면서 깨달았는데, 지금까지 8 12 18 28 식으로 2N 씩 늘어나는 계차수열인줄 알고 풀고 있었습니다. 왜 이렇게 생각했는지 모르겠는데, 당연하게 이렇다고 생각하면서 풀었네요.

이에 따라 잘못된 식으로 풀고 있었고, 틀릴 수 밖에 없었습니다.

## 올바른 접근 방식 및 해결 방식

0, 1, 0, 1 은 고정이고 0 0 1 1 부분만 0 (N + 1) x 1 (N + 1) 개만큼 늘어나는 구조입니다.

targetCount 가 T 에 도달하지 않고, N 회차를 다 돌았다면 0 1 0 1 은 고정이고 N 만 + 1하는 식으로 루프를 다시 돌리는 식으로 구현하는 것이 가장 쉽다는 것을 깨달았습니다.

## 최종 코드

```
const solution = () => {
  const arr = [0, 1, 0, 1]
  while (true) {
    n += 1

    for (let i = 0; i < n; i++) arr.push(0)
    for (let i = 0; i < n; i++) arr.push(1)

    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === K) count++

      if (count === T) {
        console.log(target % A)
        return
      }

      target++
    }
  }
}

solution()

```
